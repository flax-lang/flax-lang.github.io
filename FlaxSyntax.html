<div class="docs">
<header><h1>Flax Language Syntax</h1></header>
<p>Note that the language is still in flux, and syntax elements are subject to change</p>

<hr />

<section>


<header id="doc-general"><h2>General Syntax and Variables</h2></header>
<p>
Flax currently adopts a Swift-inspired syntax, which in turn is very much C-like. It also ignores semicolons. It's not entirely true to say that they're optional, rather they're just ignored as a syntactic token.
<br />
Of course, you still can't place it in the middle of expressions. Speaking of which, expressions and statements are the same thing, and are not distinguished in this language.

<br />
There are 11 builtin types available for variables:
</p>

<pre class="dcodesegment"><code class="lang-swift dcsinner">
Int8, Uint8, Int16, Uint16
Int32, Uint32, Int64, Uint64
Float32, Float64, Bool</code></pre>


<p>
Note that integer literals have a type of <span class="inline-code">Int64</span>.
However, the compiler will automatically cast them into an appropriate type for the expression, if the destination type is big enough. An error will be thrown if, for instance, you are trying to do this: <span class="inline-code">var x: Int8 = 400</span>
</p>

<p>
When no explicit initialiser is given, variables are initialised to a zero value that is appropriate. Pointers and integers get 0, while aggregated types (structs, classes) will have their <span class="inline-code">__automatic_init()</span> function called (explained below), unless explicitly specified with an attribute.
</p>

<hr />
<header id="doc-pointers"><h2>Pointers</h2></header>
<p>
Flax fully supports pointers, and they have an intuitive syntax. Note that unlike in C/C++, the "pointerness" of a type is bound to the type itself, not the name. It would be pretty stupid to have <span class="inline-code">var foo*: Int32</span> for an <span class="inline-code">Int32*</span>, would it not?
<pre class="dcodesegment"><code class="lang-swift dcsinner">
var vga: Int16* = 0xB8000 as Int16*
</code></pre></p>


<p>
Taking the address of a variable, as well as dereferencing a pointer, have equally familiar syntax:
<pre class="dcodesegment"><code class="lang-swift dcsinner">
var firstByte: Int16 = #vga				// dereference with '#'
var vgaPtrAgain: Int16* = &amp;firstByte	// take the address with '&amp;'
</code></pre>
</p>


<p>
Naturally, pointers can be indexed into. No bounds-checking will be done, however -- it is planned.
<pre class="dcodesegment"><code class="lang-swift dcsinner">
var foos: Int64* = calloc(8, 4) as Int64*	// will be replaced with keyword
var foo: Int64 = foos[1]
</code></pre>
</p>

<p>
Additionally, pointer arithmetic is also supported. That is to say, adding or subtracting an integer from a pointer type will in fact add or subtract from the address (stored in the pointer var) by that number multiplied by the size in bytes of the type pointed to. If that sounds confusing, the example below will help:
<pre class="dcodesegment"><code class="lang-swift dcsinner">
var qux: Int64* = 0xFF00 as Int64*
qux += 4				// actually (qux as UintPtr) += (4 * sizeof(Int64))

printf("%p", qux)		// prints 0xFF20
</code></pre>
</p>



<hr />
<header id="doc-functions"><h2>Functions</h2></header>
<p>
Functions are declared with the <span class="inline-code">func</span> keyword, proceeded by the function name, a list of arguments in parenteses, and finally the return type after a <span class="inline-code">-&gt;</span>. The return type can be omitted if the function returns Void (aka nothing).

<pre class="dcodesegment"><code class="lang-swift dcsinner">
func Foo(bar: Int64, qux: Int8*) -> Float64
{
	// ...
}
</code></pre>
</p>

<p>
Naturally, the <span class="inline-code">return</span> keyword can be used to return a value from a function. Note that it is an error not to return a value in a function with a non-Void return value.
<br />
Implicit returns are planned, but are currently not implemented yet:
<pre class="dcodesegment"><code class="lang-swift dcsinner">
func mult(a: Float32, b: Float32) -> Float32 { a * b }
</code></pre>
</p>

<p>
Flax supports calling C calling conventions (due to using LLVM), and as such two-way interaction is possible. To declare an externally-defined C function, use the <span class="inline-code">ffi</span> keyword preceeding <span class="inline-code">func</span>.
<pre class="dcodesegment"><code class="lang-swift dcsinner">
ffi func printf(x: Int8*, ...)
</code></pre>

<br />
As you can see, declaring C functions that take a variable number of arguments is supported using <span class="inline-code">...</span>, however it is currently not possible to write Flax functions with a variable number of parameters. Additionally, <span class="inline-code">ffi</span> functions are the only time where Flax functions can have no body. Finally, names still need to be given to all the parameters in the declaration -- this will be addressed eventually.
</p>

<p>
Functions can be overloaded if they take a different number of arguments, or arguments of different types between their incarnations. The Flax compiler will determine at compile time which function to call. Note that if two functions differ only in their return type, they cannot be overloaded, as the compiler usually does not have enough information to determine which function to call in most cases.
<pre class="dcodesegment"><code class="lang-swift dcsinner">
func printInt(x: Int8)    { printf("%hhd is an Int8!\n", x) }
func printInt(x: Int32)   { printf("%d is an Int32!\n", x)  }
func printInt(x: Float32) { printf("%f is a Float32!\n", x) }

printf(42 as Int8)		// 42 is an Int8
printf(581 as Int32)	// 581 is an Int32
printf(45.5 as Float32)	// 45.5 is a Float32
</code></pre>
</p>






<hr />
<header id="doc-structs"><h2>Structs</h2></header>
<p>
Structs are declared with the <span class="inline-code">struct</span> keyword.
All functions in a struct have an implicit first parameter called 'self', which is a pointer type.
Flax does not distinguish between pointer access and non-pointer access, both use the '.' operator. Yes, this means that accessing struct members through a pointer is allowed (in C/C++, this is done using <span class="inline-code">-&gt;</span>)

<pre class="dcodesegment"><code class="lang-swift dcsinner">
struct FooBar
{
	// ... members ...
}
</code></pre>
</p>


<p>
Structs can have 3 kinds of members: constructors and destructors, member variables, and functions (although theoretially init functions are still functions). Currently, the implementation of Flax limits member types to only variables and functions. Custom constructors can be specified, but currently cannot be overloaded and must take zero parameters. Destructors are not yet supported.
<br />
<pre class="dcodesegment"><code class="lang-swift dcsinner">
struct GuideToGalaxy
{
	var theAnswer: Int64
	var billionsOfPeopleOnEarth: Int64 = 7	// inline initialisers are allowed.

	// You can declare an init() function yourself
	init()
	{
		self.theAnswer = (6 * 7) * self.billionsOfPeopleOnEarth
	}

	func calculateAnswer() -> Int64
	{
		return self.theAnswer
	}
}
</code></pre>
<br />
<p>
If you remember the <span class="inline-code">__automatic_init()</span> previously mentioned, here is where it comes into play: it is called to ensure a zero-value on all member variables in a struct instance, as well as to actually assign the inline initialiser values. To disable this for whatever reason (and to leave it uninitialised), use the <span class="inline-code">@noautoinit</span> attribute.
</p>

<p>
Of course, structs are valid types everywhere, and can be used to define variables. Note that the struct definition does not need to preceed any usage of it, because the compiler takes multiple passes.
<pre class="dcodesegment"><code class="lang-swift dcsinner">
var guide1: GuideToGalaxy
var guide2: GuideToGalaxy* = &amp;guide1
</code></pre>
</p>

<p>
To access members of structs, be it variables or functions, use the <span class="inline-code">.</span> operator. For convenience when working with structs in memory (at a low level), struct-pointers can also be accessed with the dot syntax, as mentioned above, without explicitly dereferencing the variable.
<pre class="dcodesegment"><code class="lang-swift dcsinner">
var answer: Int64 = guide2.calculateAnswer()	// call directly on pointer
guide1.billionsOfPeopleOnEarth -= 4				// asteroid?
</code></pre>
</p>

<hr />
<header id="doc-arrays"><h2>Arrays</h2></header>
<p>
Currently, only fixed-length arrays are supported in Flax. These arrays have compile-time bounds checking, and will generate an error if an attempt is made to access memory outside its allocated length. When creating an array in Flax, all elements will get their default value, usually zero -- unless the <span class="inline-code">@noautoinit</span> attribute is specified.
<pre class="dcodesegment"><code class="lang-swift dcsinner">
var i64Arr: Int64[100]
var something = i64Arr[40]	// okay
i64Arr[591] = 58774			// error
</code></pre>
</p>



<hr />
<header id="doc-ifelse"><h2>If/Else</h2></header>
<p>
Flax supports the ubiquitous if/elseif/else construct, and its syntax is quite unimaginative, especially to users of other programming languages. A few special points to note -- firstly, the condition to evalulate can be a non-boolean type, in which case a comparison is made in the form of <span class="inline-code">!= 0</span>, meaning all other values evaluate as <span class="inline-code">true</span>. Secondly, the parentheses after the if statement are optional. Finally, the implicit braces rule of C/C++ is not supported -- all if/else statements must be surrounded in braces.
<pre class="dcodesegment"><code class="lang-swift dcsinner">
if someCondition
{
	// ...
}
else if someOtherCondition &amp;&amp; today != "tuesday"
{
	// ...
}
else
{
	// ...
}
</code></pre>
</p>

<p>
Both the <span class="inline-code">&amp;&amp;</span> and the <span class="inline-code">||</span> boolean operators are short-circuiting. To those unfamiliar, this means that for an expression <span class="inline-code">a &amp;&amp; b</span>, <span class="inline-code">b</span> will never be evaluated (or if it is a function that returns a boolean, it will never be called) if <span class="inline-code">a</span> is false.
<br />
Conversely, for <span class="inline-code">a || b</span>, if <span class="inline-code">a</span> is true, <span class="inline-code">b</span> will never be evaluated.
</p>



<hr />
<header id="doc-loops"><h2>Loops</h2></header>

<p>
Flax currently supports 3 main kinds of loops; the <span class="inline-code">while</span> loop, the <span class="inline-code">do-while</span> loop and the infinite loop. Note that implicit braces are not permitted as well for these. They have the following syntax:
<pre class="dcodesegment"><code class="lang-swift dcsinner">
while someCondition
{
	// do stuff while someCondition is true
}

do {

	// do stuff at least once, then only while someCondition is true

} while(someCondition)

loop {
	// keep doing stuff
}
</code></pre>
</p>

<p>
As an aside, blocks without any keyword (eg. <span class="inline-code">{ printf("Hi") }</span>) will not be executed. To ensure that such a block is evaluated, preceed the block with either <span class="inline-code">do</span> or <span class="inline-code">loop</span>, depending on the effect you wish to achieve. An interesting tidbit is that all 3 of the above loops share the same AST node, and as such, you can do interesting things with them:
<pre class="dcodesegment"><code class="lang-swift dcsinner">
do {
	// executed once
}

loop {
	// infinite loop
}

do {
	// execute while foo != 0
} while(foo)

loop {
	// same as do ... while(foo)
} while(foo)
</code></pre>
</p>









<hr />
<header id="doc-mangling"><h2>Name Mangling</h2></header>
<p>
There are two main types of name mangling in Flax, mangling of function names and the mangling of function names as members of structs. In both cases, mangling results in a rather long final name, but the benefit of this is that it maintains some sense of readability as to the signature of the function.
<br />
<br />
<br />


<header><h3>Functions</h3></header>
To handle outputting LLVM bitcode (which does not support overloading), Flax function names are mangled, unless specified otherwise. It uses its own cranky mangling system, observe: <span class="inline-code">[basename]#_[param1Type]_[paramNType]</span>
<br />
If a function takes no parameters, it is mangled as if it has a single parameter of type <span class="inline-code">Void</span>. To specify that a function should not be mangled, use the <span class="inline-code">@nomangle</span> attribute. Attributes will be discussed in detail below.
<br />
<br />
<br />
<br />



<header><h3>Functions in Structs</h3></header>
The mangling of functions in struct types is very simple compared to the actual mangling of function names; the name of the struct is essentially just prepended to the mangled name of the function: <span class="inline-code">__struct#[structName]_[mangledFuncName]</span>
</p>


</section>

</div>

<!--


<br/>
#### Attributes ####
This will be short, since there aren't a lot of attributes
Attributes are declared using the '@name' syntax:

```swift
@nomangle func Foo(...) { ... }
```
In fact, 'private', 'internal' and 'public' are attributes with special syntax.
User-defined attributes and some form of reflection (at runtime) are planned.

<br />
#### Control Flow ####
If-else statements are supported, and naturally nestable.

```swift
var x: Int8 = 10
if x > 20
{
	...
}
else if x < 5
{
	...
}
else
{
	...
}
```


As you can see, parentheses around the conditional expression
are optional.
Furthermore, single-line C-style ifs like this
are not supported, and will not be.

```c
if(cond)
	doSomething();

``` -->
