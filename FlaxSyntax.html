<div class="docs">
<header><h1>Flax Language Syntax</h1></header>
<p>Note that the language is still in flux, and syntax elements are subject to change</p>

<hr />

<section>


<header id="doc-general"><h2>General Syntax and Variables</h2></header>
<p>
Flax currently adopts a Swift-inspired syntax, which in turn is very much C-like. It also ignores semicolons. It's not entirely true to say that they're optional, rather they're just ignored as a syntactic token.
<br />
Of course, you still can't place it in the middle of expressions. Speaking of which, expressions and statements are the same thing, and are not distinguished in this language.

<br />
There are 11 builtin types available for variables:
</p>

<pre class="dcodesegment"><code class="lang-swift dcsinner">
Int8, Uint8, Int16, Uint16
Int32, Uint32, Int64, Uint64
Float32, Float64, Bool</code></pre>


<p>
Note that integer literals have a type of <span class="inline-code">Int64</span>.
However, the compiler will automatically cast them into an appropriate type for the expression, if the destination type is big enough. An error will be thrown if, for instance, you are trying to do this: <span class="inline-code">var x: Int8 = 400</span>
</p>

<p>
When no explicit initialiser is given, variables are initialised to a zero value that is appropriate. Pointers and integers get 0, while aggregated types (structs, classes) will have their <span class="inline-code">__automatic_init()</span> function called (explained below), unless explicitly specified with an attribute.
</p>

<hr />
<header id="doc-pointers"><h2>Pointers</h2></header>
<p>
Flax fully supports pointers, and they have an intuitive syntax. Note that unlike in C/C++, the "pointerness" of a type is bound to the type itself, not the name. It would be pretty stupid to have <span class="inline-code">var foo*: Int32</span> for an <span class="inline-code">Int32*</span>, would it not?
<pre class="dcodesegment"><code class="lang-swift dcsinner">
var vga: Int16* = 0xB8000 as Int16*
</code></pre></p>


<p>
Taking the address of a variable, as well as dereferencing a pointer, have equally familiar syntax:
<pre class="dcodesegment"><code class="lang-swift dcsinner">
var firstByte: Int16 = #vga				// dereference with '#'
var vgaPtrAgain: Int16* = &amp;firstByte	// take the address with '&amp;'
</code></pre>
</p>


<p>
Naturally, pointers can be indexed into. No bounds-checking will be done, however -- it is planned.
<pre class="dcodesegment"><code class="lang-swift dcsinner">
var foos: Int64* = calloc(8, 4) as Int64*	// will be replaced with keyword
var foo: Int64 = foos[1]
</code></pre>
</p>

<p>
Additionally, pointer arithmetic is also supported. That is to say, adding or subtracting an integer from a pointer type will in fact add or subtract from the address (stored in the pointer var) by that number multiplied by the size in bytes of the type pointed to. If that sounds confusing, the example below will help:
<pre class="dcodesegment"><code class="lang-swift dcsinner">
var qux: Int64* = 0xFF00 as Int64*
qux += 4				// actually (qux as UintPtr) += (4 * sizeof(Int64))

printf("%p", qux)		// prints 0xFF20
</code></pre>
</p>



<hr />
<header id="doc-functions"><h2>Functions</h2></header>
<p>
Functions are declared with the <span class="inline-code">func</span> keyword, proceeded by the function name, a list of arguments in parenteses, and finally the return type after a <span class="inline-code">-&gt;</span>. The return type can be omitted if the function returns Void (aka nothing).

<pre class="dcodesegment"><code class="lang-swift dcsinner">
func Foo(bar: Int64, qux: Int8*) -> Float64
{
	// ...
}
</code></pre>
</p>

<p>
Naturally, the <span class="inline-code">return</span> keyword can be used to return a value from a function. Note that it is an error not to return a value in a function with a non-Void return value.
<br />
Implicit returns are planned, but are currently not implemented yet:
<pre class="dcodesegment"><code class="lang-swift dcsinner">
func mult(a: Float32, b: Float32) -> Float32 { a * b }
</code></pre>
</p>

<p>
Flax supports calling C calling conventions (due to using LLVM), and as such two-way interaction is possible. To declare an externally-defined C function, use the <span class="inline-code">ffi</span> keyword preceeding <span class="inline-code">func</span>.
<pre class="dcodesegment"><code class="lang-swift dcsinner">
ffi func printf(x: Int8*, ...)
</code></pre>

<br />
As you can see, declaring C functions that take a variable number of arguments is supported using <span class="inline-code">...</span>, however it is currently not possible to write Flax functions with a variable number of parameters. Additionally, <span class="inline-code">ffi</span> functions are the only time where Flax functions can have no body. Finally, names still need to be given to all the parameters in the declaration -- this will be addressed eventually.
</p>

<p>
Functions can be overloaded if they take a different number of arguments, or arguments of different types between their incarnations. The Flax compiler will determine at compile time which function to call. Note that if two functions differ only in their return type, they cannot be overloaded, as the compiler usually does not have enough information to determine which function to call in most cases.
<pre class="dcodesegment"><code class="lang-swift dcsinner">
func printInt(x: Int8)    { printf("%hhd is an Int8!\n", x) }
func printInt(x: Int32)   { printf("%d is an Int32!\n", x)  }
func printInt(x: Float32) { printf("%f is a Float32!\n", x) }

printf(42 as Int8)		// 42 is an Int8
printf(581 as Int32)	// 581 is an Int32
printf(45.5 as Float32)	// 45.5 is a Float32
</code></pre>
<br />
To handle outputting LLVM bitcode (which does not support overloading), Flax function names are mangled, unless specified otherwise. It uses its own cranky mangling system, observe: <span class="inline-code">[basename]#_[param1Type]_[paramNType]</span>
<br />
If a function takes no parameters, it is mangled as if it has a single parameter of type <span class="inline-code">Void</span>. To specify that a function should not be mangled, use the <span class="inline-code">@nomangle</span> attribute. Attributes will be discussed in detail below.

</p>






<hr />
<header id="doc-structs"><h2>Structs</h2></header>
<p>
Structs are declared with the <span class="inline-code">struct</span> keyword.
All functions in a struct have an implicit first parameter called 'self', which is a pointer type.
Flax does not distinguish between pointer access and non-pointer access, both use the '.' operator. Yes, this means that accessing struct members through a pointer is allowed (in C/C++, this is done using <span class="inline-code">-&gt;</span>)

<pre class="dcodesegment"><code class="lang-swift dcsinner">
struct FooBar
{
	// ... members ...
}
</code></pre>
</p>


<p>
Structs can have 3 kinds of members: constructors and destructors, member variables, and functions (although theoretially init functions are still functions). Currently, the implementation of Flax limits member types to only variables and functions. Custom constructors can be specified, but currently cannot be overloaded and must take zero parameters. Destructors are not yet supported.
<br />
<pre class="dcodesegment"><code class="lang-swift dcsinner">
struct GuideToGalaxy
{
	var theAnswer: Int64
	var billionsOfPeopleOnEarth: Int64 = 7	// inline initialisers are allowed.

	// You can declare an init() function yourself
	init()
	{
		self.theAnswer = (6 * 7) * self.billionsOfPeopleOnEarth
	}

	func calculateAnswerToLifeTheUniverseAndEverything() -> Int64
	{
		return self.theAnswer
	}
}
</code></pre>
<br />
<p>
If you remember the <span class="inline-code">__automatic_init()</span> previously mentioned, here is where it comes into play: it is called to ensure a zero-value on all member variables in a struct instance, as well as to actually assign the inline initialiser values. To disable this for whatever reason (and to leave it uninitialised), use the <span class="inline-code">@noautoinit</span> attribute.
</p>

</section>

</div>

<!--

<br/>
#### Structs ####

```swift
struct GuideToGalaxy
{
	// structs can obviously contain members
	var theAnswer: Int64
	var billionsOfPeopleOnEarth: Int64 = 7			// inline initialisers are allowed.

	// You can declare an init() function yourself
	init()
	{
		// unfortunately, init functions taking parameters are not yet supported.
		self.theAnswer = (100 - 94) * self.billionsOfPeopleOnEarth

		// all variables are always initialised with an appropriate zero-value, regardless of the presence of a user-defined
		// initialiser.
	}

	func calculateAnswerToLifeTheUniverseAndEverything() -> Int64
	{
		// implicit return (TODO: not supported currently)
		self.theAnswer
	}
}
```

Structs can be used just like any other type:

```swift
struct Hitchhiker
{
	var guide: GuideToGalaxy
}

var aHitchhiker: Hitchhiker								// this is initialised with a default initialiser.
var bHitchhiker: Hitchhiker* = &aHitchhiker

// this should theoretically work, but has not been tested extensively. (struct members in structs)
var answer: Int64 = bHitchhiker.guide.calculateAnswerToLifeTheUniverseAndEverything()

```
functions in structs are mangled as well, since LLVM does not support namespaced functions.
They follow this pattern:
`__struct#[structName]_[mangledFuncName]`



<br/>
#### Arrays ####
Arrays are declared as such:

```swift
var intArr: Int64[100]
```

Neither dynamic arrays nor initialiser lists are supported yet.
You can however always use a pointer. Those subscript as well.
speaking of subscripting:

```swift
var someInt: Int64 = intArr[50]
```

Fortunately, since the length of the array is known at compile time, this will fail

```swift
var someOtherInt: Int64 = intArr[1585]
```

Of course, array elements can be assigned to.

```swift
intArr[40] = 42
```



<br/>
####Â Attributes ####
This will be short, since there aren't a lot of attributes
Attributes are declared using the '@name' syntax:

```swift
@nomangle func Foo(...) { ... }
```
In fact, 'private', 'internal' and 'public' are attributes with special syntax.
User-defined attributes and some form of reflection (at runtime) are planned.

<br />
#### Control Flow ####
If-else statements are supported, and naturally nestable.

```swift
var x: Int8 = 10
if x > 20
{
	...
}
else if x < 5
{
	...
}
else
{
	...
}
```


As you can see, parentheses around the conditional expression
are optional.
Furthermore, single-line C-style ifs like this
are not supported, and will not be.

```c
if(cond)
	doSomething();

``` -->
