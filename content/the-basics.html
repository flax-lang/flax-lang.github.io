<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="">
	<meta name="author" content="">

	<title>Flax Programming Language</title>

	<!-- Bootstrap Core CSS -->
	<link href="../css/bootstrap.css" rel="stylesheet">

	<!-- Custom CSS -->
	<link href="../css/style.css" rel="stylesheet">

	<!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
	<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
	<!--[if lt IE 9]>
		<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
		<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
	<![endif]-->

	<link rel="stylesheet" href="../fonts/font-awesome-4.4.0/css/font-awesome.min.css">


	<link rel="stylesheet" href="../css/prism.css" />
	<script src="../js/prism.js"></script>


	<!-- jQuery -->
	<script src="../js/jquery.js"></script>
	<script src="../js/init.js"></script>
</head>

<body>
	<div id="wrapper">
		<a href="#menu-toggle" class="menu-toggle"><i class="fa fa-list"></i></a>

		<div id="sidebar-wrapper"></div>

		<!-- Page Content -->
		<div id="page-content-wrapper">
		<div class="container-fluid">
		<div class="row">
		<div class="col-lg-12" id="main-view">

			<div class="col-lg-12 content-view" id="the-basics">
			<h1 class="content-header">The Basics</h1>
			<hr />

			<p>
			Flax provides a variety of different types, including <code>Int</code> for integers,
			<code>Bool</code> for boolean values, <code>Float</code> for floating-point
			numbers, and <code>String</code> for textual data. In addition to these familiar types, Flax also
			employs the use of tuple types, which are essentially anonymous structs without named members, facilitating an easy way
			to pass pieces of related data around.
			</p>

			<p>
			Flax is a <i>type-safe</i> language, which means the language helps you to be clear about the types of values your code can
			work with. If part of your code expects a <code>String</code>, type safety prevents you from passing it an
			<code>Int</code> by mistake. Type safety helps you catch and fix errors as early as possible in the
			development process.
			</p>












			<h3 class="subcontent-header" id="constants-and-variables">Constants and Variables</h3>
			<h3 class="anchor-clicker"></h3><p>

			Constants and variables are a way to associate a value, for example <code>10</code> or <code>"John Doe"</code> with a name, for
			instance <code>age</code> or <code>name</code>. Constants cannot be changed once they are assigned, while variables can be given
			a new value later on in the program.
			</p>


			<h4 class="subcontent-header" id="declaring-cs-and-vs">Declaring Constants and Variables</h4>
			<h4 class="anchor-clicker"></h4><p>

			As with any imperative language, constants and variables need to be declared before they are used. In Flax, variables are
			declared with the <code>var</code> keyword, while constants can be declared either with
			<code>val</code> or <code>let</code>.
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
let maximumNumberOfLoginAttempts = 10
var currentLoginAttempt = 0</code></pre>


			<p>
			This code can be read as:
			</p>

			<p>
			"Declare a new constant called <code>maximumNumberOfLoginAttempts</code>, and give it a value of 10. Then,
			declare a new variable called <code>currentLoginAttempt</code>, and give it an initial value of 0".
			</p>

			<p>
			In this example, the maximum number of allowed login attempts is declared as a constant, because the maximum value never changes.
			The current login attempt counter is declared as a variable, because this value must be incremented after each failed login attempt.
			</p>

			<aside class="note">
				<p class="note-title">Note</p>
				<p class="note-content">If a stored value in your code is not going to change, always declare it as a constant with the let
				keyword. Use variables only for storing values that need to be able to change.
				</p>
			</aside>








			<h4 class="subcontent-header" id="type-annotations">Type Annotations</h3>
			<h4 class="anchor-clicker"></h4><p>

			You can provide a <i>type annotation</i> when you declare a constant or variable, to be clear about the kind of values the
			constant or variable can store. Write a type annotation by placing a colon after the constant or variable name, followed by a space,
			followed by the name of the type to use.
			</p>

			<p>
			This example provides a type annotation for a variable called <code>welcomeMessage</code>, to indicate that the variable can store
			<code>String</code> values:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
var welcomeMessage: String</code></pre>

			<p>
			The colon in the declaration means <i>"... of type ..."</i>, so the code above can be read as:
			</p>

			<p>
			"Declare a variable called <code>welcomeMessage</code> that is of type <code>String</code>".
			</p>

			<p>
			The phrase "of type <code>String</code>" means "can store any <code>String</code> value". Think of it as meaning
			"the type of thing" (or "the kind of thing") that can be stored.
			</p>

			<p>
			The welcomeMessage variable can now be set to any string value without error:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
welcomeMessage = "Hello"</code></pre>


			<aside class="note">
				<p class="note-title">Note</p>
				<p class="note-content">
				It is rare that you need to write type annotations in practice. If you provide an initial value for a constant or variable at the
				point that it is defined, the compiler can almost always infer the type to be used for that constant or variable. In the
				<code>welcomeMessage</code> example above, no initial value is provided, and so the type of the <code>welcomeMessage</code>
				variable is specified with a type annotation rather than being inferred from an initial value.
				</p>
			</aside>











			<h4 class="subcontent-header" id="naming-cs-and-vs">Naming Variables and Constants</h3>
			<h4 class="anchor-clicker"></h4><p>

			Constant and variable names can contain almost any character, including Unicode characters:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
let œÄ = 3.14159
let ‰Ω†Â•Ω = "‰Ω†Â•Ω‰∏ñÁïå"
let üê∂üêÆ = "dogcow"</code></pre>

			<p>
			Constant and variable names cannot contain whitespace characters, mathematical symbols, arrows, private-use (or invalid) Unicode
			code points, or line- and box-drawing characters. Nor can they begin with a number, although numbers may be included elsewhere within
			the name.
			</p>

			<p>
			Once you‚Äôve declared a constant or variable of a certain type, you can‚Äôt redeclare it again with the same name, or change it to
			store values of a different type. Nor can you change a constant into a variable or a variable into a constant.
			</p>

			<p>
			You can change the value of an existing variable to another value of a compatible type. In this example, the value of
			<code>friendlyWelcome</code> is changed from <code>"Hello!"</code> to <code>"Bonjour!"</code>:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
var friendlyWelcome = "Hello!"
friendlyWelcome = "Bonjour!"
// friendlyWelcome is now "Bonjour!"</code></pre>

			<p>
			Unlike a variable, the value of a constant cannot be changed once it is set. Attempting to do so is reported as an error when your
			code is compiled:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
let name = "John"
name = "Joe"
// compile-time error, name cannot be changed</code></pre>













			<h3 class="subcontent-header" id="comments">Comments</h3>
			<h3 class="anchor-clicker"></h3><p>

			Use comments to include non-executable text in your code, as a note or reminder to yourself. Comments are ignored by the compiler
			when your code is compiled.
			</p>

			<p>
			Comments in Flax are very similar to comments in C. Single-line comments begin with two forward-slashes (<code>//</code>):
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
// this is a comment</code></pre>

			<p>
			Multiline comments start with a forward-slash followed by an asterisk (<code>/*</code>) and end with an asterisk followed by a
			forward-slash (<code>*/</code>):
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
/* this is also a comment,
but written over multiple lines */</code></pre>


			<p>
			Unlike multiline comments in C, multiline comments in Flax can be nested inside other multiline comments. You write nested
			comments by starting a multiline comment block and then starting a second multiline comment within the first block. The second block
			is then closed, followed by the first block:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
/* this is the start of the first multiline comment
/* this is the second, nested multiline comment */
this is the end of the first multiline comment */</code></pre>

			<p>
			Nested multiline comments enable you to comment out large blocks of code quickly and easily, even if the code already contains
			multiline comments.
			</p>

			<aside class="note">
				<p class="note-title">Note</p>
				<p class="note-content">
				The nested-comment example only looks screwed-up because prism.js doesn't handle it properly. Rest assured it works properly
				in the compiler.
				</p>
			</aside>











			<h3 class="subcontent-header" id="semicolons">Semicolons</h3>
			<h3 class="anchor-clicker"></h3><p>
			Flax does not require you to write a semicolon (<code>;</code>) after each statement in your code, although you
			can do so if you wish. However, semicolons are <i>required</i> if you want to write multiple separate statements on a single line:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
let cat = "üê±"; printf("%s", cat)
// prints "üê±"</code></pre>








			<h3 class="subcontent-header" id="integers">Integers</h3>
			<h3 class="anchor-clicker"></h3><p>

			<i>Integers</i> are whole numbers with no fractional component, such as <code>42</code> and <code>-23</code>. Integers are either
			signed (positive, zero, or negative) or unsigned (positive or zero).
			</p>

			<p>
			Flax provides signed and unsigned integers in 8, 16, 32, and 64 bit forms. These integers follow a naming convention similar to C,
			in that an 8-bit unsigned integer is of type <code>Uint8</code>, and a 32-bit signed integer is of type <code>Int32</code>.
			</p>


			<h4 class="subcontent-header" id="integer-bounds">Integer Bounds</h4>
			<div class="anchor-clicker"></div><p>

			You can access the minimum and maximum values of each integer type with its <code>min</code> and <code>max</code> properties:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
let minValue = Uint8.min  // minValue is equal to 0, and is of type Uint8
let maxValue = Uint8.max  // maxValue is equal to 255, and is of type Uint8</code></pre>


			<p>
			Naturally, the values of these properties are of the appropriate-sized number type (such as <code>Uint8</code> in the example above)
			and can therefore be used in expressions alongside other values of the same type.
			</p>

			<p>
			Finally, the <code>Int</code> and <code>Uint</code> are convenience types that are available. These should be used instead of
			integer types with explicit sizes, when possible. Exceptions could include explicitly conveying the size of the type for some
			external interface, or when reading data from a foreign source.
			</p>

			<ul class="point-list">
				<li>
				On 32-bit platforms, <code>Int</code> and <code>Uint</code> are the same size as
				<code>Int32</code> and <code>Uint32</code> respectively.
				</li>

				<li>
				On 64-bit platforms, <code>Int</code> and <code>Uint</code> are the same size as
				<code>Int64</code> and <code>Uint64</code> respectively.
				</li>
			</ul>

			<p>
			A summary of the minimum and maximum values for each signed integer type is presented below:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
let i8Min = Int8.min		// -128
let i8Max = Int8.max		// +127

let i16Min = Int16.min		// -32,768
let i16Max = Int16.max		// +32,767

let i32Min = Int32.min		// ‚àí2,147,483,648
let i32Max = Int32.max		// +2,147,483,647

let i64Min = Int64.min		// ‚àí9,223,372,036,854,775,808
let i64Max = Int64.max		// +9,223,372,036,854,775,807</code></pre>


			<p>
			Similarly, the bounds of the unsigned integer types are below:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
let u8Min = Uint8.min		// 0
let u8Max = Uint8.max		// 255

let u16Min = Uint16.min		// 0
let u16Max = Uint16.max		// 65,535

let u32Min = Uint32.min		// 0
let u32Max = Uint32.max		// 4,294,967,295

let u64Min = Uint64.min		// 0
let u64Max = Uint64.max		// 18,446,744,073,709,551,615</code></pre>


			<aside class="note">
				<p class="note-title">Note</p>
				<p class="note-content">
				For general code, use <code>Uint</code> only when you specifically need an unsigned integer type with the same size as the
				platform‚Äôs native word size. If this is not the case, Int is preferred, even when the values to be stored are known to be
				non-negative. A consistent use of Int for integer values aids code interoperability, avoids the need to convert between different
				number types, and matches default integer type inference for constants.
				</p>
			</aside>









			<h3 class="subcontent-header" id="floating-point-numbers">Floating-Point Numbers</h3>
			<h3 class="anchor-clicker"></h3><p>

			Floating-point numbers are numbers with a fractional component, such as <code>0.1</code>, <code>-273.15</code>, and
			<code>3.1415926535897932384626</code>.
			</p>

			<p>
			Floating-point types can represent a much wider range of values than integer types, and can store numbers that are much larger or
			smaller than can be stored in an <code>Int</code>. Two floating-point number types are available:
			</p>

			<ul class="point-list">
				<li><code>Float64</code>, or <code>Double</code>, represents a 64-bit floating-point number.</li>
				<li><code>Float32</code>, or <code>Float</code>, represents a 32-bit floating-point number.</li>
			</ul>

			<p>
			<code>Float32</code> and <code>Float64</code> are interchangable with <code>Float</code> and <code>Double</code> respectively.
			</p>

			<p>
			Note that floating-point numbers are always signed, and do not have an unsigned version.
			</p>

			<aside class="note">
				<p class="note-title">Note</p>
				<p class="note-content">
				<code>Float64</code> has a precision of at least 15 decimal digits, whereas the precision of <code>Float32</code> can be as
				little as 6 decimal digits. The appropriate floating-point type to use depends on the nature and range of values you need to work
				with in your code. In situations where either type would be appropriate, <code>Float64</code> is preferred.
				</p>
			</aside>











			<h3 class="subcontent-header" id="types-and-inference">Types and Type Inference</h3>
			<h3 class="anchor-clicker"></h3><p>

			Types are the basis of every sane programming language. Everything has a type -- expressions, variables, and functions, to
			name a few. Since types play such a fundamental role in the language, the usage of these types must be made as easy as
			possible, and the possibility of making mistakes must be reduced as far as possible.
			</p>

			<h4 class="subcontent-header" id="type-safety">Type Safety</h3>
			<h4 class="anchor-clicker"></h4><p>

			Flax is a statically-typed language; that is to say, the types of all expressions and variables are known at compile-time.
			As such, the compiler is able to provide <i>type-safety</i>, in contrast to other languages such as Python <i>(ew)</i> that
			might throw runtime errors when mismatched types are found. This ensures that <i>good</i>, <i>helpful</i> error messages
			are given to the programmer as early as possible, to reduce the occurrence of mistakes.
			</p>


			<h4 class="subcontent-header" id="type-inference">Type Inference</h3>
			<h4 class="anchor-clicker"></h4><p>

			However, often times type safety comes at a cost of having to specify or <i>annotate</i> variables and expressions with explicit
			types. In Flax, the compiler is capable of inferring, to a basic degree, the appropriate type based on what is going on. Note that
			this does not in any way diminish the type-safety of Flax -- the types are all present, except they are automatically deduced by
			the compiler instead of needing to be manually specified.
			</p>


			<p>
			One of the places where type inference is most useful is when assigning initial values to variables or constants. In such cases, the
			type of the variable is quite evident based on the right-hand-side of the assignment, and explicit types do not have to be specified:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
let meaningOfLife = 42
// meaningOfLife is inferred to be of type Int</code></pre>


			<p>
			As you might have guessed, integer literals are always inferred to have type <code>Int</code>. Naturally, when explicit types are
			provided on the variable, the literal is automatically coerced into the correct type:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
let someByte: Uint8 = 61
// 61 is converted to Uint8 first, then assigned to someByte</code></pre>


			<p>
			Similarly, floating point literals are always inferred to have type <code>Double</code>:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
let someFloat = 3.1415
// someFloat is inferred to be of type Double</code></pre>



			<aside class="note">
				<p class="note-title">Future</p>
				<p class="note-content">
				Flax currently does not have facilities for whole-program type inference, namely something like a
				<a href="https://en.wikipedia.org/wiki/Hindley‚ÄìMilner_type_system">Hindley-Milner type</a> inference system. Type inference
				currently is limited to simple, expression-based inference. For external-facing code, such as functions, types must still be
				annotated.
				</p>
			</aside>









			<h4 class="subcontent-header" id="numeric-literals">Numeric Literals</h4>
			<h4 class="anchor-clicker"></h4><p>

			There are currently three main forms of numeric literals supported in Flax: integer literals, floating-point literals, and
			hexadecimal literals. The first two have already been introduced, but hexadecimal literals are, at their heart, just another
			representation for integer literals:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
let someInt = 240
let someHex = 0xF0
// someInt === someHex</code></pre>

			<p>
			As can be seen, hexadecimal literals can be expressed by prefixing the number with <code>0x</code>, and the proceeding digits can
			range from <code>0</code> to <code>F</code>, as opposed to <code>0</code> to simply <code>9</code> with decimal numbers.
			</p>






			<h4 class="subcontent-header" id="implicit-type-coercion">Implicit Type Coercion</h3>
			<h4 class="anchor-clicker"></h4><p>

			To reduce the friction experienced by the programmer, the Flax compiler allows several implicit type coercions, ie. allowing types
			to be converted to-and-from each other without explicit casts. These implicit coercions are similar in nature to those in C or C++.
			</p>

			<p>
			These coercions fall under three main categories: <code>Int</code> to <code>Int</code>, <code>Int</code> to <code>Float</code>, and
			polymorphic coercions. The latter will be discussed in a later section.
			</p>

			<p>
			<code>Int</code> to <code>Int</code> coercions mainly involve up-casting, or increasing the bitwidth, of an integer. For example,
			a function accepting an <code>Int64</code> argument can be passed a variable of type <code>Int8</code>, because it can be safely
			coerced into an <code>Int64</code> without loss of data.
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
let someSmallInt: Int8 = 50
func eatLargeInt(someInt: Int64)
{
	// ...
}

eatLargeInt(someSmallInt) // okay</code></pre>

			<p>
			Similarly, <code>Int</code> types can also be implicitly coerced into floating-point types without losing data. As such, the
			following code will compile and run without errors:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
func eatDouble(db: Double)
{
	// ...
}

eatDouble(10) // okay</code></pre>

			<p>
			In this case, <code>10</code> becomes <code>10.0</code>.





			<h3 class="subcontent-header" id="booleans">Booleans</h3>
			<h3 class="anchor-clicker"></h3><p>

			Boolean values in Flax are a logical type -- they can either have a value of <code>true</code>, or a value of <code>false</code>.
			Naturally, <code>true</code> and <code>false</code> are constants provided by the compiler, with a type of <code>Bool</code>.

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
let pigsCanFly = false
let skyIsBlue = true</code></pre>

			<p>
			In the example above, both the constants <code>pigsCanFly</code> and <code>skyIsBlue</code> were inferred to have a type of
			<code>Bool</code>, since they were initialised with boolean literals.
			</p>

			<p>
			Boolean types are often used to control the flow of the program, through constructs such as <code>if</code>-statements or
			<code>while</code>-loops. Both will be explored later.
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
if pigsCanFly
{
	printf("What just happened??\n")
}
else
{
	printf("All is well with the world.\n")
}</code></pre>















			<h3 class="subcontent-header" id="typealiases">Type Aliases</h3>
			<h3 class="anchor-clicker"></h3><p>

			Type aliases define an alternative name for an existing type. type aliases are defined with the typealias keyword.
			</p>

			<p>
			Type aliases are useful when you want to refer to an existing type by a name that is contextually more appropriate, such as when
			working with data of a specific size from an external source:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
typealias AudioSample = UInt16</code></pre>


			<p>
			Once you define a type alias, you can use the alias anywhere you might use the original name:
			</p>


<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
var maxAmplitudeFound = AudioSample.min
// maxAmplitudeFound is now 0</code></pre>

			<p>
			Here, <code>AudioSample</code> is defined as an alias for <code>Uint16</code>. Because it is an alias, referencing
			<code>AudioSample.min</code> actually references Uint16.min, which provides an initial value of 0 for the
			<code>maxAmplitudeFound</code> variable.
			</p>



			<h4 class="subcontent-header" id="typealiases-weak-strong">Strong vs. Weak Type Aliases</h4>
			<h4 class="anchor-clicker"></h4><p>

			In Flax, there are two kinds of type aliases -- weak and strong type aliases. By default, typealiases are defined as
			weak aliases. This means that it the aliased types are not treated as distinct types, and you can assign between them:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
typealias Kilometres = Int
var orbitalPerigeeOfISS: Kilometres = 409	// assignment is transparent
let someRandomInt = 40

orbitalPerigeeOfISS = someRandomInt			// allowed</code></pre>


			<p>
			However, this might not be the most appropriate behaviour. If distiction is required, mark the typealias with the
			<code>@strong</code> attribute. When an alias is strongly typed, any attempt to assign a value that is not of the new type
			will result in a compile-time error. Reusing the example above:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
@strong typealias Kilometres = Int
var orbitalPerigeeOfISS: Kilometres = 409	// intial assigment is transparently handled
let someRandomInt = 40

orbitalPerigeeOfISS = someRandomInt			// error: assigning type Int to var of type Kilometres</code></pre>


			<aside class="note">
				<p class="note-title">Future</p>
				<p class="note-content">
				Type aliases are currently heavily feature-regressed in the compiler. Strong type aliases might become the default form
				of aliases in the future.
				</p>
			</aside>










			<h3 class="subcontent-header" id="tuples">Tuples</h3>
			<h3 class="anchor-clicker"></h3><p>

			<i>Tuples</i> are a convenient way to group multiple values into a single construct that is easy to manipulate and pass around
			to other pieces of code. The components of a tuple can have distinct or similar types, and tuples can have any number of member
			types.</p>

			<p>
			In this example, <code>(404, "Not Found")</code> is a tuple that describes an HTTP status code. An HTTP status code is a special
			value returned by a web server whenever you request a web page. A status code of 404 Not Found is returned if you request a webpage
			that doesn‚Äôt exist.
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
let http404Error = (404, "Not Found")
// http404Error has type (Int, String)</code></pre>

			<p>
			The <code>http404Error</code> tuple provides a convenient way to group two related values together: the numerical error code,
			<code>404</code>, as well as a human-readable error message, <code>"Not Found"</code>.
			</p>


			<p>
			Tuples are the preferred way to return two related values from a function, as opposed to traditional C-like methods such as
			passing pointers to functions. Currently, the constituent values in tuples can be accessed by using the dot operator and a zero-based
			index:
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
let numError = http404Error.0
let strError = http404Error.1

printf("Encountered HTTP Error %d, %s\n", numError, strError)
// prints "Encountered HTTP Error 404, Not Found".</code></pre>


			<p>
			Naturally, if you try <code>someTuple.3</code> in a tuple with only 3 elements, the compiler will give an error, since there is no
			fourth element in the tuple.
			</p>


			<p>
			</p>


			<aside class="note">
				<p class="note-title">Future</p>
				<p class="note-content">
				Tuple decomposition (eg. <code>let (x, y) = someTuple</code>) is currently not supported, but will be in the future. Right now
				this dot-operator method is the only way to access tuple members.
				</p>
			</aside>

			<aside class="note">
				<p class="note-title">Future</p>
				<p class="note-content">
				Named tuples are also not supported, but will be in the future. Numerical indices only, for now.
				</p>
			</aside>

















			<h3 class="subcontent-header" id="pointers">Pointers</h3>
			<h3 class="anchor-clicker"></h3><p>

			The final piece in the puzzle of Flax's basic types is pointers. Through pointers, Flax offers unparalleled low-level power,
			allowing for the manipulation of raw memory, with facilities such as pointer arithmetic, to aid in this process.
			</p>

			<p>
			The behaviour of pointers in Flax is similar to that in C and C++. You can take the address of variables on the stack, pass
			pointers to functions, etc. Of course, pointers allow one to subvert the type system through type-casting, and thus should be used
			with care.
			</p>

			<p>
			Pointer types are declared by adding <code>*</code>s after the type that is pointed to. Naturally, multiple indirections are
			supported. Taking the address is done with <code>&amp;</code>, and dereferencing is done with <code>#</code>.
			</p>

<pre class="dcodesegment dcsouter"><code class="lang-swift dcsinner">
var someVariable = 40

var somePtr: Int* = &amp;someVariable;
someVariable += 1

printf("%d\n", #somePtr)
// prints "41"</code></pre>



			<div class="next-prev-footer">
				<div class="footer-prev"><a href="intro-page.html"><i class="fa fa-caret-left"></i> Introduction to Flax</a></div>
				<div class="footer-next"><a href="basic-operators.html">Basic Operators <i class="fa fa-caret-right"></i></a></div>
			</div>


			</div>



		</div>
		</div>
		</div>
		</div>


	<!-- Bootstrap Core JavaScript -->
	<script src="../js/bootstrap.min.js"></script>
</body>
</html>









